## 1 问题描述
给定一个字符串，求其最长的回文子串。

## 2 一些方法
### 2.1 Brute Force
可以先找到所有子串，然后判断每个子串是否为回文，期间记录最长回文子串即可：
- 一个长度为 $n$ 的字符串的子串的个数为： $n(n + 1) / 2$ ；
- 判断字符串是否为回文时间复杂度为 $O(n)$;

因此，总的时间复杂度为 $O(n^3)$ 。

### 2.2 Better Than Brute Force
以第 i 个字符为中心，向两边扩展，即可得到：以第 i 个字符为中心的最长回文（时间复杂度为 $O(n)$），对每个字符进行同样的操作（总共需执行n次），期间记录下最长回文即可。

显然，总的时间复杂度为 $O(n^2)$ 。

## 3 马拉车算法
直接一步步陈述马拉车算法的各个步骤，容易使人犯懵（这一步是干什么？为什么要这么做...）,为了避免这种情况，我们先对马拉车算法思路进行简单梳理：
- 第一步：先对 **原字符串** 进行 **预处理** 得到 **预处理字符串**；
- 第二步：计算 **预处理字符串的最长回文子串**；
- 第三步：根据 **预处理字符串的最长回文子串** 计算 **原字符串的最长回文子串**

先明确下算法大概的流程，不理解没关系，接着往下看。

### 3.1 预处理（第一步）
第一步正是马拉车算法的 **巧妙** 之处所在，下面，我们来看看它到底妙在了哪里。

在 **Better Than Brute Force** 方案中：
- 我们需要考虑回文子串长度为奇数（eg，bcb）、偶数（eg，bccb）的两种情况；

manacher的预处理方法，巧妙地避开了这个问题：
- 在每个字符左右两侧都加上特殊字符（不存在于原字符串中的字符，这里使用 '#'）；
- 原字符串："acbcd";
- 预处理后字符串："#a#c#b#c#d#";

通过这样的预处理，使得回文子串长度只能为奇数，完全不必讨论偶数情况（即，**预处理字符串的回文子串的长度必为奇数**）。

除了上述预处理，还需要再进行一次预处理（先知道有这一步就行，代码中注释会进行解释）
- 在预处理后的字符串左侧再加上另一个特殊字符（不存在于原字符串中的字符，这里使用'$'，使用 '#' 也是没有问题的）
- "#a#c#b#c#d#" 变为 "$#a#c#b#c#d#"

Ps：为了避免绕口，进行以下声明
- 预处理字符串的回文子串用 pp 表示，例如 "#b#c#b#" ；
- 原字符串的回文子串用 sp 表示，例如 "bcb"；
- 两者是对应关系；

### 3.2 计算最长 pp（第二步）
第二步是马拉车算法的 **核心** 。

首先需要理解两个重要而又晦涩难懂的辅助变量：
- mx：回文子串能延伸到的最右端位置；
- id：延伸到最右端的位置的回文子串的中心点位置（预处理字符串回文子串长度必为奇数，所以一定有中心点位置）；

其它一些变量及其含义：
- p[id]：以索引 id 为中心的最长 pp 的半径；
- i：当前访问字符的索引；
- j：i 关于 id 的对称位置（即，j = 2 * id - i）；

明确了以上变量的含义，下面理解马拉车算法中最核心的一行代码。
```cpp
p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
```
当mx <= i 时：i 处于 mx 右端，没有什么可用信息，只能确定以 i 为中心的最长pp（pp_i）的半径至少为1（到底是多少就需要进行比较了）；

当mx > i 时：i 在mx延伸范围内，存在可用信息：
- 当mx - i >= p[j] 时，以 j 为中心的最长pp（pp_j）被包含在以 id 为中心的最长pp内（pp_id），根据对称，以 i 为中心的最长pp（pp_i）也包含在pp_id内且p[i] = p[j]，如下图所示：

{%asset_img 1.png%}

- 当mx - i < p[j] 时，根据对称，我们可以确定最长pp_i的半径至少为 mx - i（到底是多少就需要进行比较了），如下图所示：

{%asset_img 2.png%}

max(p[i]) 即为最长 pp 的半径， i 为最长 pp 中心字符的索引。

### 3.3 根据最长pp计算最长sp（第三步）
**1、sp长度计算**

先观察以下两种情况：
- pp "#b#c#b#" 长度为7，半径为4，其所对应的 sp "bcb" 长度为3；
- pp "#b#c#c#b#" 长度为9，半径为5，其所对应的sp "bccb" 长度为4；

可见：
- sp长度 = pp半径 - 1；

**2、sp起始索引计算**

知道了 sp 的长度，只需要再知道其在原字符串中的起始索引，就可以截取到 sp，那么如何计算 sp 的起始索引呢？

这里分别以字符串"ambcbdn" 和 "ambccbdn"为例：

"cambcbdn" （最长sp为奇数情况）：
- 预处理后为："$#c#a#m#b#c#b#d#n#"；
- pp：#b#c#b#，半径为4，其中心字符为'c'索引为10；
- sp：bcb，起始索引为 (10 - 4) / 2 = 3;

"ambccbdn"（最长sp为偶数情况）：
- 预处理后为："$#a#m#b#c#c#b#d#n#"；
- pp：#b#c#c#b#，半径为5，其中心字符为'#'索引为9；
- sp：bccb，起始索引为 (9 - 5) / 2 = 2;

可见：
- sp起始索引 =（pp中心字符索引 - pp半径）/ 2；

**3、计算最长sp**
在第二步中，我们计算得到了最长pp，利用上述方法计算出其所对应的 sp。因为其为最长 pp，因此所得到的 sp 为最长 sp，也就是最终所要求的结果。

### 3.4 小结一下
步骤：
- 预处理：加#、加$；
- 计算最长 pp；
    - 半径：r ；中心字符索引：c ；
- 计算最长 sp
    - 长度：r - 1；
    - 起始索引：(c - r) / 2；
    - 从原字符串中裁减出最长 sp。

### 3.5 代码实现
```cpp
#include <string>
#include <vector>
string process(string s){
    string res = "$#";
    for(int i = 0; i < s.size(); ++i)
    {
        //这样写不行的
        //res += s[i] + "#";
        res += s[i];
        res += '#';
    }
    return res;
}

string manacher(string s){
    string t = process(s);
    vector<int> p(t.size(), 0);
    int mx = 0;
    int id = 0;
    int r = 0;
    int c = 0;
    for(int i = 1; i < t.size(); ++i)
    {
        p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
        //@的唯一用途在这里！有哨兵的味道
        //左侧不会出现数组越界情况
        //那怎么解释右侧也不会数组越界呢？
        //哈哈，不知道了吧
        //字符串后面有一个结束符的！！！
        while(t[i + p[i]] == t[i - p[i]])
            ++p[i];
        if(mx < i + p[i])
        {
            mx = i + p[i];
            id = i;
        }
        if(p[i] > r)
        {
            r = p[i];
            c = i;
        }
    }
    return s.substr((c - r) / 2, r - 1);
}
```
### 3.6 时间复杂度
看了代码之后，接下来分析下它的时间复杂度为什么是 O(n)

如果去掉下面代码，其它部分时间复杂度显然是 O(n)：
```cpp
while(t[i + p[i]] == t[i - p[i]])
        ++p[i];
```
单独考虑上述代码：
- 由于其每执行一次，会将mx值推进一格，t的长度为 O(n)，因此，上面的循环总共执行 O(n) 次，其时间复杂度也就为 O(n)。

因此，马拉车算法的最终复杂度也就是 O(n)。
## 4 练习题
[LeetCode 5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
[LeetCode 647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
## 5 参考
[马拉车算法](https://blog.csdn.net/qq_40859951/article/details/87966123)
