同 KMP 算法一样，Sunday 和 BM 算法也可以看作是 Brute Force 方法的优化（也是跳过了一些不必要的匹配过程，不过选择跳过的依据有所不同）。

## 1 Sunday 算法
当 模式串 $t$ （长度为 $n$） 和 主串 $s$ （长度为 $m$）的第 $i$ 位从头开始进行匹配时：
```cpp
      i           i + n                  （主串索引）
      |             |                    （当前索引为 i）
... x x x x x ... x x ...                （主串）
      y y y y ... y                      （模式串）
      |                                  （当前索引为 0）
      0 1 2 3 . n - 1                    （模式串索引）
```
按照 Brute Force 思路，当发生失配时，模式串应右移一维，然后和主串的第 $i + 1$ 位开始从头匹配：
```cpp
      i + 1       i + n                  （主串索引）
        |           |                    （当前索引为 i + 1）
... x x x x x x ... x ...                （主串）
        y y y y ... y                    （模式串）
        |                                （当前索引为 0）
        0 1 2 3 . n - 1                  （模式串索引）
```
此时，主串的 $i + n$ 位一定会参与匹配：
- 如果主串的 $i + n$ 位跟模式串的最后一位不相同，那么模式串完全没有必要和主串的第 $i + 1$ 位从头开始匹配（最后一步肯定会失败，匹配了也是白匹配）；
- 如果主串的 $i + n$ 位跟模式串的倒数第二位也不相同，那么模式串完全没有必要和主串的第 $i + 2$ 位从头开始匹配；
- ...
- 当主串的 $i + n$ 位终于与模式串的倒数第 $x$ 位相同时，那么模式串才有必要和主串的第 $i + x$ 位从头开始匹配；

为了能够快速定位到模式串中最后一个与主串第 $i + n$ 位字符相同的字符的位置，需要提前计算出模式串中每种字符最后一次出现的位置（倒数第几位）。

这就完了？！完了，下面是代码实现：
```cpp
int sunday(const string &s, const string &t) {
    int m = s.size(), n = t.size();
    //记录模式串中每种字符最后一次出现的位置（倒数第几位），默认值为倒数第 n + 1 位
    vector<int> offset(256, n + 1);
    for(int i = 0; i < n; ++i) offset[t[i]] = n - i;

    //i < m - n，会漏掉最后一个子串
    //i <= m - n 会导致 s[i + n] = s[m] 访问到字符串结尾标志
    for(int i = 0; i <= m - n; i += offset[s[i + n]]) {
        bool flag = true;
        for(int j = 0; j < n; ++j) {
            if(s[i + j] == t[j]) continue;
            flag = false;
            break;
        }
        //匹配成功
        if(flag) return i;
    }
    return -1;
}
```